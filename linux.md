
- [Linux](#linux)
  - [Дистрибутивы](#Дистрибутивы)
  - [Терминал](#Терминал)
    - [Самые важные команды](#Самые_важные_команды)
    - [Системные вызовы](#Системные_вызовы)
  - [Процессы](#Процессы)
    - [Сигналы-убийства-процессов](#Сигналы-убийства-процессов)
    - [OOM](#OOM)
  

# Дистрибутивы

Различные дистрибутивы Linux систем. Вообще все зависит от задач и принятых стандартов в компании. Где-то успешно используют Debian/Ubuntu. Где-то успешно CentOS/RHEL.
Если сильно обобщать, то для нас, devops, разница не большая. 
Немного различаются используемые тулы. Самое большое различие это пакетные менеджеры и репозитории пакетов для этих менеджеров.
Краткая выжимка:

## **Сравнение Различных Дистрибутивов Linux:**

### **Alpine Linux:**
- **Размер:** Alpine Linux известен своей компактностью. Он имеет очень низкие системные требования и маленький размер образа, что делает его популярным выбором для контейнеризации.
- **Пакетный менеджер:** Использует `apk` для управления пакетами. Пакеты обычно меньше по размеру благодаря использованию musl libc вместо glibc.
- **Назначение:** Часто используется в Docker-контейнерах и встроенных системах из-за своей компактности и минималистичного подхода.

### **Ubuntu:**
- **Простота использования:** Ubuntu - один из самых популярных дистрибутивов благодаря своей простоте установки и использования.
- **Пакетный менеджер:** Использует `dpkg` и `apt` для управления пакетами.
- **Поддержка:** Предоставляет обширную поддержку и сообщество пользователей. Существует версия с долгосрочной поддержкой (LTS) для стабильности.

### **Debian:**
- **Стабильность:** Debian славится своей стабильностью и безопасностью. Он имеет строгие процессы тестирования и большое сообщество разработчиков.
- **Пакетный менеджер:** Использует `dpkg` и `apt` для управления пакетами.
- **Универсальность:** Debian может использоваться на серверах, настольных компьютерах и встроенных устройствах. Версии с долгосрочной поддержкой доступны для серверных приложений.

### **CentOS:**
- **Совместимость с RHEL:** CentOS - это бесплатный клон коммерческого Red Hat Enterprise Linux (RHEL). Он обеспечивает совместимость с платформой RHEL.
- **Пакетный менеджер:** Использует `rpm` и `yum` (или `dnf` в более новых версиях) для управления пакетами.
- **Поддержка:** CentOS также предоставляет версии с долгосрочной поддержкой, что делает его популярным для бизнес-приложений и серверов.

### **Red Hat Linux:**
- **Профессиональная Поддержка:** Red Hat Linux - это коммерческий дистрибутив, предоставляющий профессиональную поддержку и сервисы для корпоративных клиентов.
- **Пакетный менеджер:** Использует `rpm` и `yum` (или `dnf` в более новых версиях) для управления пакетами.
- **Безопасность:** Red Hat имеет высокие стандарты безопасности и обеспечивает регулярные обновления безопасности для своих продуктов.

# Терминал

# Самые важные команды

## Команда `man` в Linux

Команда `man` в Linux предназначена для отображения руководств по использованию других команд прямо в командной строке. Слово "man" является сокращением от "manual", что означает "руководство". Это очень полезная команда, которая помогает получить подробную информацию о том, как использовать другие команды и программы в Linux.

## Команда `uname` в Linux

Команда `uname` дает множество интересной информации о вашей системе

# Системные вызовы

Системные вызовы (system calls) в Linux - это интерфейс между пользовательскими приложениями и ядром операционной системы. Они представляют собой способ, с помощью которого приложения могут запрашивать операционной системе выполнение привилегированных задач, таких как чтение или запись в файл, создание нового процесса или управление памятью. Вот несколько распространенных системных вызовов в Linux:

### 1. **`fork()`**
Системный вызов `fork()` используется для создания нового процесса. Он создает точную копию текущего процесса, включая код, данные и файловые дескрипторы. Этот системный вызов возвращает значение 0 в дочернем процессе и идентификатор нового дочернего процесса в родительском процессе.

### 1.2 **`clone()`**
Cистемный вызов в ядре Linux, который используется для создания новых процессов (потоков). Он является более гибкой и мощной версией стандартного системного вызова `fork()`, который используется для создания новых процессов в Linux. Однако, в отличие от `fork()`, clone позволяет контролировать различные аспекты создания нового процесса, такие как использование общей памяти и файловых дескрипторов.

### 2. **`exec()`**
`exec()` используется для выполнения новой программы внутри текущего процесса. Он загружает новый исполняемый файл в текущий процесс и начинает его выполнение, заменяя текущий код и данные новыми.

### 3. **`wait()` и `waitpid()`**
`wait()` и `waitpid()` используются для ожидания завершения дочернего процесса. Они блокируют вызывающий процесс до тех пор, пока дочерний процесс не завершится, после чего возвращают статус завершения дочернего процесса.

### 4. **`open()` и `close()`**
`open()` используется для открытия файла, а `close()` - для его закрытия. Системный вызов `open()` возвращает файловый дескриптор, который можно использовать для последующих операций ввода-вывода.

### 5. **`read()` и `write()`**
`read()` используется для чтения данных из файла или другого источника ввода, а `write()` - для записи данных в файл или другой источник вывода. Они принимают файловый дескриптор, буфер и количество байт для чтения или записи.

### 6. **`kill()`**
`kill()` используется для отправки сигнала другому процессу. Этот системный вызов позволяет процессу отправить сигнал другому процессу или группе процессов.

### 7. **`exit()`**
`exit()` используется для завершения текущего процесса. Приложение вызывает этот системный вызов, чтобы завершить свою работу и вернуть статус завершения операционной системе.

### 8. **`chdir()`**
`chdir()` позволяет процессу изменить свою текущую рабочую директорию на указанную.

### 9. **`stat()` и `fstat()`**
`stat()` используется для получения информации о файле, включая его атрибуты и метаданные. `fstat()` делает то же самое, но для уже открытого файла (используется файловый дескриптор).

Это лишь небольшой набор из множества системных вызовов, доступных в Linux. Каждый из них предоставляет определенный функционал и используется в различных сценариях программирования на Linux.


# Процессы

В операционной системе Linux, процессы - это выполняющиеся программы. Когда вы запускаете программу, операционная система создает процесс для этой программы, чтобы она могла выполнять свои задачи. Подробнее рассмотрим основные аспекты процессов в Linux:

### 1. **Идентификатор процесса (PID):**
Каждый процесс в Linux имеет уникальный идентификатор процесса, называемый PID. PID - это целое число, которое уникально для каждого процесса в системе.

### 2. **Состояния процессов:**
Процессы в Linux могут находиться в различных состояниях. Некоторые из основных состояний включают в себя:
   - **Running (R):** Процесс выполняется в данный момент.
   - **Sleeping (S):** Процесс ожидает события, например, ввода данных.
   - **Stopped (T):** Процесс был приостановлен и может быть возобновлен позже.
   - **Zombie (Z):** Процесс завершил выполнение, но его запись о процессе осталась в таблице процессов до тех пор, пока родительский процесс не получит информацию о завершении.
   - **D (Uninterruptible Sleep):** Процесс находится в непрерываемом сне, часто ожидая завершения операций ввода/вывода. Процессы в этом состоянии обычно не реагируют на сигналы.

### 3. **Управление Процессами:**
   - **Запуск Процессов:** Процессы могут быть запущены из командной строки или из скриптов.
   - **Завершение Процессов:** Процессы можно завершить с помощью команды `kill`, указав PID процесса.
   - **Фоновый и Передний План:** Процессы могут быть запущены в фоновом режиме (с добавлением `&` в конце команды) или в переднем плане.

### 4. **Управление Приоритетом:**
В Linux каждый процесс имеет приоритет выполнения. Команда `nice` позволяет запускать процессы с различными приоритетами. Пользователь с правами суперпользователя (root) может изменять приоритет процесса с помощью команды `renice`.

### 5. **Многозадачность:**
Linux поддерживает многозадачность, что означает, что множество процессов может выполняться параллельно, используя различные ядра процессора.

### 6. **Дерево Процессов:**
Процессы в Linux образуют дерево, где каждый процесс имеет родительский процесс, за исключением процесса с PID 1, который является исключением и называется инициализационным процессом.

# Сигналы убийства процессов

Отдельной темой является убивание процессов. Убить процесс можно по - разному. Все зависит от сигнала, который отправляется при убийстве.

Вот некоторые распространенные сигналы в Unix-подобных системах:

### 1. **SIGTERM (15):**
Этот сигнал отправляется процессу, чтобы попросить его завершить выполнение. Это стандартный способ завершения процесса.

### 2. **SIGKILL (9):**
Этот сигнал немедленно завершает процесс и не предоставляет ему возможности выполнить какие-либо завершающие операции.

### 3. **SIGINT (2):**
Этот сигнал отправляется процессу, когда пользователь нажимает клавишу прерывания (обычно Ctrl + C в терминале). Это предназначено для прерывания выполнения процесса.

### 4. **SIGHUP (1):**
Этот сигнал отправляется процессу, когда терминал, с которого был запущен процесс, закрывается. Он обычно используется для перезапуска или переконфигурации процесса.

### 5. **SIGCHLD (17):**
Этот сигнал отправляется родительскому процессу, когда дочерний процесс завершается.

### 6. **SIGSEGV (11):**
Этот сигнал отправляется процессу при попытке обращения к недопустимой области памяти (ошибка доступа к памяти).

### 7. **SIGUSR1 (10) и SIGUSR2 (12):**
Эти сигналы не имеют фиксированного значения и могут использоваться приложениями для собственных целей.

# OOM

`OOM` (Out Of Memory) Killer - это механизм в ядре Linux, который активируется в случае, если системе не хватает оперативной памяти для выполнения процессов. Когда система исчерпывает всю доступную оперативную память и не может освободить больше ресурсов, `OOM Killer` вмешивается и автоматически завершает (убивает) один или несколько процессов, чтобы освободить оперативную память и предотвратить полный сбой системы из-за нехватки памяти.

### Как работает OOM Killer:

1. **Мониторинг памяти:**
   Ядро Linux постоянно мониторит использование оперативной памяти. Когда система начинает исчерпывать свободные и буферизованные/кэшированные ресурсы, и нет возможности освободить достаточно памяти через страницы-подкачки (`swap`), OOM Killer активируется.

2. **Оценка процессов:**
   Каждый процесс в системе оценивается по различным критериям, таким как размер памяти, время жизни, приоритет и другие параметры. Эта оценка помогает ядру выбрать процесс для завершения.

3. **Выбор процесса для завершения:**
   OOM Killer выбирает процесс с наименьшей важностью для системы (низким приоритетом) и завершает его. Это может быть процесс, использующий много памяти и/или времени процессора.

4. **Убийство процесса:**
   Выбранный процесс уничтожается, и его ресурсы освобождаются. Это позволяет системе вернуть некоторое количество оперативной памяти и продолжить работу.

5. **Логирование события:**
   Ядро логирует событие убийства процесса в системный журнал, что позволяет администраторам анализировать причины проблемы и предпринимать соответствующие действия для предотвращения ее повторения.

Обратите внимание, что OOM Killer - это крайний меры. Он используется в ситуациях, когда нехватка памяти критически важна и система должна продолжать функционировать в целом. Поэтому важно проактивно мониторить использование памяти и оптимизировать приложения для эффективного использования ресурсов, чтобы избежать срабатывания OOM Killer.