# Docker Images

Docker Image (образ Docker) — это легковесный, автономный пакет, который содержит всё необходимое для запуска приложения: код, среду выполнения, библиотеки, переменные окружения и файлы конфигурации. Образы Docker предоставляют консистентное окружение на всех этапах разработки, тестирования и развертывания.

Основные особенности Docker Images:

1. **Неизменяемость**: Как только образ создан, он не изменяется. Это гарантирует, что один и тот же образ будет работать одинаково в разных окружениях.

2. **Слоевая архитектура**: Образы Docker состоят из слоев, каждый из которых представляет собой различные изменения в файловой системе. Когда вы создаете образ на основе существующего образа и вносите изменения, создается новый слой. Это делает образы компактными и позволяет многократно использовать общие слои между различными образами.

3. **Версионирование**: Вы можете помечать образы тегами для идентификации различных версий. Это упрощает управление версиями и откат изменений.

4. **Репозитории**: Образы можно хранить в репозиториях, таких как Docker Hub или частные реестры. Это облегчает распределение, совместное использование и развертывание образов.

5. **Dockerfile**: Чтобы создать образ Docker, обычно используется файл конфигурации под названием Dockerfile. В этом файле описаны инструкции для создания образа, такие как основной образ, установка необходимого ПО, копирование файлов приложения и установка переменных окружения.

Как работают образы:

1. **Создание**: Образы Docker создаются с помощью команды `docker build`, которая принимает Dockerfile и создает образ на основе инструкций в этом файле.

2. **Запуск**: Когда вы запускаете контейнер с помощью команды `docker run`, Docker берет образ и создает из него работающий экземпляр — контейнер.

3. **Сохранение и распределение**: Вы можете сохранять свои образы в репозиториях (например, Docker Hub) с помощью команды `docker push` и извлекать их с помощью команды `docker pull`.

Образы Docker играют ключевую роль в контейнеризации, поскольку они предоставляют стандартизированное и консистентное окружение для приложений, устраняя проблему "работает у меня на машине".

# Dockerfile

Dockerfile — это текстовый файл, который содержит инструкции для создания образа Docker. С помощью Dockerfile разработчики могут автоматизировать процесс настройки и конфигурации окружения для своего приложения. Когда вы выполняете команду `docker build`, Docker читает инструкции из Dockerfile и шаг за шагом создает образ.

Давайте рассмотрим основные компоненты Dockerfile и часто используемые инструкции:

1. **FROM**: Определяет базовый образ, который будет использоваться. Например, `FROM ubuntu:20.04` будет использовать образ Ubuntu версии 20.04 как стартовую точку.

2. **RUN**: Выполняет команду и создает новый слой в образе с результатом этой команды. Применяется для установки пакетов и других операций. Например: `RUN apt-get update && apt-get install -y nginx`.

3. **CMD**: Задает команду по умолчанию, которая будет выполнена при запуске контейнера. В Dockerfile может быть только одна инструкция CMD.

4. **ENTRYPOINT**: Аналогично CMD, но позволяет конфигурировать контейнер так, чтобы он работал как исполняемый файл. Часто используется в комбинации с CMD.

5. **WORKDIR**: Устанавливает рабочую директорию для последующих инструкций в Dockerfile.

6. **ENV**: Устанавливает переменные окружения. Например: `ENV MY_VAR=value`.

7. **COPY & ADD**: Копируют файлы и папки из локальной машины в файловую систему образа. В то время как `COPY` просто копирует файлы, `ADD` имеет дополнительные функции (например, может распаковывать архивы).

8. **EXPOSE**: Информирует Docker о том, что контейнер будет слушать на указанном сетевом порту при выполнении.

9. **VOLUME**: Создает точку монтирования для работы с постоянным хранилищем или для монтирования файлов из хоста.

10. **LABEL**: Добавляет метаданные к образу, например, версию или описание.

11. **USER**: Задает имя пользователя (или UID), от имени которого будут запускаться последующие инструкции.

При создании Dockerfile рекомендуется следовать лучшим практикам, чтобы минимизировать размер конечного образа, ускорить процесс сборки и улучшить безопасность. Например, объединяйте команды в одной инструкции RUN, чтобы уменьшить количество слоев, и очищайте кэш пакетного менеджера после установки пакетов.

Пример простого Dockerfile для веб-приложения на Node.js:

```Dockerfile
# Используем официальный образ Node.js
FROM node:14

# Создаем директорию для приложения
WORKDIR /usr/src/app

# Копируем package.json и package-lock.json
COPY package*.json ./

# Устанавливаем зависимости
RUN npm install

# Копируем остальные файлы приложения
COPY . .

# Объявляем порт, который будет слушать приложение
EXPOSE 8080

# Задаем команду для запуска приложения
CMD ["npm", "start"]
```

После создания Dockerfile вы можете собрать образ, используя команду `docker build`, и затем запустить контейнер на основе этого образа.

# K8s 

Kubernetes состоит из ряда компонентов, работающих вместе для предоставления надежной, масштабируемой и управляемой платформы для контейнеризированных приложений. Рассмотрим основные компоненты Kubernetes:

1. **etcd**: Распределенное хранилище конфигурации. Используется Kubernetes для хранения всей конфигурации кластера, включая состояние кластера и метаданные.

2. **API Server (kube-apiserver)**: Основной контрольный интерфейс для Kubernetes. Все операции (команды `kubectl`, работа других компонентов) взаимодействуют с кластером через API сервер.

3. **Controller Manager (kube-controller-manager)**: Отвечает за контроллеры, которые обеспечивают регулирование состояния кластера. Например, если один из узлов выходит из строя, контроллер узлов заботится о его замене.

4. **Scheduler (kube-scheduler)**: Определяет, на каком узле будет запущен новый под (контейнер). Селектор учитывает различные факторы, такие как требования ресурсов, ограничения и антиселекторы.

5. **kubelet**: Агент, запущенный на каждом узле кластера. Он обеспечивает выполнение подов, назначенных этому узлу, и отправляет информацию о состоянии узла и его нагрузке на мастер.

6. **kube-proxy**: Сетевой прокси, который работает на каждом узле и обеспечивает сетевое взаимодействие подов между собой и с внешним миром.

# Сеть K8s

Сеть в Kubernetes (k8s) устроена таким образом, чтобы обеспечить связь между различными компонентами и обеспечить эффективное масштабирование приложений. В Kubernetes применяются следующие ключевые понятия и компоненты в контексте сети:

1. **Поды и IP-адреса**: В Kubernetes каждый под получает собственный IP-адрес. Это обеспечивает прозрачность сети, где приложения внутри подов могут общаться друг с другом, как если бы они были в той же сети, даже если они размещены на разных узлах.

2. **Сервисы**: Сервис в Kubernetes представляет собой абстракцию, которая определяет постоянный IP-адрес, DNS-имя и порт. Это позволяет клиентам обращаться к приложению, не заботясь о том, где именно запущены поды этого приложения.

3. **Kube-proxy**: Этот компонент работает на каждом узле и обеспечивает сетевое взаимодействие подов и сервисов. Он может работать в нескольких режимах, таких как `iptables` или `ipvs`, для перенаправления трафика к нужным подам.

4. **Сетевые плагины**: Хотя базовая сетевая модель Kubernetes обеспечивает определенные функции, существуют различные сетевые плагины (например, Calico, Flannel, Weave и другие), которые добавляют дополнительные функции или изменяют стандартное поведение.

5. **Сетевые политики**: Позволяют определять, какие поды могут общаться друг с другом. Это полезно для создания изолированных сред или ограничения доступа к определенным службам.

6. **Ingress**: Если вы хотите предоставить доступ к вашему приложению извне кластера, вы можете использовать ресурс Ingress. Это правило, которое определяет, как трафик должен быть направлен извне кластера к вашим сервисам.

7. **DNS**: Kubernetes предоставляет внутреннюю службу DNS для автоматического разрешения имен сервисов на их IP-адреса, что упрощает обнаружение служб.

8. **Масштабируемость и высокая доступность**: Благодаря подсетям и маршрутизации, k8s способен обрабатывать тысячи узлов и десятки тысяч подов.

Сетевая модель Kubernetes предназначена для обеспечения простоты, масштабируемости и безопасности. Она предоставляет набор стандартных абстракций, которые позволяют разработчикам и администраторам сосредоточиться на развертывании и управлении приложениями, не вдаваясь в детали нижележащей сетевой инфраструктуры.

# Сеть K8S екстендет

Сетевые плагины в Kubernetes расширяют и настраивают функциональность сети, позволяя обеспечивать разнообразные требования к изоляции, производительности и интеграции с существующими сетевыми решениями. В Kubernetes используется стандарт CNI (Container Network Interface), что позволяет легко взаимодействовать с множеством сетевых плагинов.

Вот несколько популярных сетевых плагинов для Kubernetes:

1. **Calico**: Основан на технологии BGP и позволяет создавать сети на основе IP, применять сетевые политики и обеспечивать высокую производительность. Calico может работать в разных режимах, включая чистый режим L3 или с использованием сетевого оверлея.

2. **Flannel**: Это простой и надежный оверлей-плагин, который создает виртуальную сеть между узлами кластера. Flannel может использовать различные бэкенды, такие как VXLAN или host-gw.

3. **Weave**: Предоставляет сеть и DNS для подов. Weave создает виртуальную сеть, которая соединяет поды, независимо от того, на каком узле они находятся.

4. **Cilium**: Использует технологию eBPF для обеспечения сетевых политик, мониторинга и усиленной безопасности. Cilium способен управлять трафиком на уровне L3/L4, а также на уровне L7, например, HTTP.

5. **Romana**: Плагин для сетей на основе маршрутизации и политик безопасности, который работает на уровне L3 без необходимости оверлея.

6. **Kube-router**: Простой плагин, который предоставляет функции маршрутизации, балансировки нагрузки и сетевых политик на основе технологий Linux, таких как IPVS и iptables.

7. **Multus**: Не является заменой основным сетевым плагинам, но позволяет подам иметь несколько сетевых интерфейсов, интегрируясь с другими плагинами CNI.

Эти плагины обычно предоставляют дополнительные возможности, такие как:

- **Сетевые политики**: Определение, какие поды могут общаться друг с другом и как они могут доступаться извне.
- **Оверлейные сети**: Позволяют подам общаться друг с другом, даже если они находятся в разных физических сетях.
- **Интеграция с существующей инфраструктурой**: Некоторые плагины предоставляют возможности для интеграции с текущей сетевой инфраструктурой или оборудованием.

Выбор сетевого плагина зависит от специфических требований к производительности, безопасности, совместимости и других факторов в вашем окружении.

# BGP

BGP (Border Gateway Protocol) — это стандартный протокол маршрутизации, предназначенный для обмена информацией о маршрутах в интернете между автономными системами (AS). Автономная система — это набор IP-сетей, управляемых одной организацией и имеющих общую политику маршрутизации.

Вот несколько ключевых характеристик и особенностей BGP:

1. **Путь Векторной Маршрутизации**: BGP является протоколом пути векторной маршрутизации. Вместо того чтобы просто отслеживать стоимость пути к целевому адресу (как делают многие другие протоколы маршрутизации), BGP отслеживает полный путь (список AS) к целевому адресу. Это предотвращает зацикливание маршрутов и позволяет применять сложные политики маршрутизации.

2. **Масштабируемость**: BGP спроектирован так, чтобы обрабатывать тысячи маршрутов в больших, гетерогенных сетях, таких как интернет.

3. **Политики Маршрутизации**: Один из основных преимуществ BGP — возможность настройки сложных политик маршрутизации. Организации могут управлять трафиком на основе различных критериев, таких как производительность, стоимость или политические решения.

4. **Агрегация Маршрутов**: BGP поддерживает агрегацию маршрутов, что позволяет сокращать размер таблицы маршрутизации.

5. **Безопасность**: BGP традиционно имеет ряд проблем с безопасностью, таких как подделка маршрутов. Однако есть улучшения и инициативы, такие как RPKI (Resource Public Key Infrastructure), которые стремятся улучшить безопасность BGP.

BGP широко используется в интернете интернет-провайдерами и центрами обработки данных для обмена информацией о маршрутизации. Также он может быть использован в приватных сетях, особенно в больших корпоративных сетях или облачных средах для управления маршрутизацией и обеспечения отказоустойчивости.

# VXLAN

VXLAN (Virtual Extensible LAN) — это сетевой протокол оверлея, позволяющий создавать виртуальные частные сети (VLAN) в масштабируемых и гетерогенных дата-центрах. VXLAN был разработан для решения проблем с ограничением количества VLAN в современных дата-центрах, которое составляет 4096, увеличивая этот лимит до 16 миллионов идентификаторов сети.

Основные характеристики и преимущества VXLAN:

1. **Масштабирование**: VXLAN позволяет создавать до 16 миллионов изолированных сетей в дата-центре, в то время как стандартный VLAN допускает всего 4096 идентификаторов.

2. **Оверлей**: VXLAN использует методику "оверлея", где трафик одной сети инкапсулируется в трафик другой сети. В случае VXLAN это обычно трафик UDP.

3. **Взаимодействие с существующими сетями**: VXLAN может работать поверх существующей инфраструктуры без необходимости каких-либо изменений на физическом уровне.

4. **Поддержка многих производителей**: Многие современные сетевые устройства и программное обеспечение поддерживают VXLAN, что делает его популярным выбором для внедрения оверлейных сетей.

5. **Создание сегментов**: С помощью VXLAN можно создавать логически изолированные сегменты в одной и той же физической сети.

VXLAN работает путем инкапсуляции оригинальных Ethernet-кадров в UDP-пакеты для передачи между различными VXLAN сегментами. Этот процесс инкапсуляции происходит на "VTEP" (VXLAN Tunnel Endpoint), который может быть реализован как на физических, так и на виртуальных устройствах.

В современных дата-центрах, особенно в средах с высокой степенью виртуализации и облачной инфраструктурой, VXLAN часто используется для обеспечения гибкости и масштабируемости сетевой инфраструктуры.

# Host-gw

`host-gw` (host-gateway) — это один из режимов работы некоторых сетевых плагинов для Kubernetes, в частности Flannel. Этот режим предоставляет способ настройки сетевой связности между подами в разных узлах кластера без использования сетевого оверлея, в отличие от других режимов, таких как VXLAN.

В режиме `host-gw`, когда под на одном узле (например, Node A) хочет общаться с подом на другом узле (например, Node B), трафик напрямую маршрутизируется на шлюз Node B, минуя любые оверлейные сети. Это достигается за счёт создания маршрутов на каждом узле, которые указывают на подсети подов других узлов через IP-адреса их соответствующих узлов.

Преимущества режима `host-gw`:

1. **Простота**: Нет необходимости в сложной настройке или дополнительном программном обеспечении для управления оверлейной сетью.
2. **Производительность**: Так как нет оверлея, нет дополнительной нагрузки на CPU или задержек, связанных с инкапсуляцией пакетов.

Ограничения режима `host-gw`:

1. **Требования к сети**: Все узлы в кластере должны быть в одной и той же L2 сети, и между ними должна быть возможность маршрутизации.
2. **Не подходит для многозональных или облачных развертываний**: Этот режим не работает, если узлы развернуты в разных сетевых зонах или облаках, где между узлами нет прямой маршрутизации.

В целом, режим `host-gw` может быть полезным в некоторых конкретных сценариях, особенно когда все узлы находятся в одной и той же локальной сети и есть желание упростить сетевую конфигурацию.

# k8s static pods

В Kubernetes "static pod" (или статический под) — это особый тип пода, который напрямую управляется демоном kubelet на определенном узле, без вмешательства API сервера Kubernetes.

Вот как работают статические поды:

1. **Конфигурация**: Kubelet на конкретном узле мониторит каталог (например, `/etc/kubernetes/manifests/`) на наличие манифестов подов.
2. **Создание**: Когда kubelet обнаруживает манифест пода в этом каталоге, он автоматически создает и запускает соответствующий под на том же узле.
3. **Регистрация в API сервере**: Хотя статический под управляется напрямую kubelet'ом, он все равно будет видимым в общем списке подов кластера. Если вы выполните `kubectl get pods`, вы увидите статический под в списке, но с именем узла в качестве префикса.
4. **Удаление**: Чтобы удалить статический под, нужно удалить его манифест из каталога, который мониторится kubelet'ом.

Преимущества и использование статических подов:

- **Запуск системных служб**: Статические поды часто используются для запуска критически важных системных служб на каждом узле. Например, многие распределения Kubernetes используют статические поды для запуска компонентов управления кластером, таких как kube-controller-manager или kube-scheduler.
  
- **Независимость от состояния кластера**: Поскольку статические поды управляются напрямую kubelet'ом и не зависят от API сервера Kubernetes, они могут продолжать работать, даже если есть проблемы с остальной частью кластера.

Однако следует помнить, что статические поды обычно используются для специфических системных задач и могут не подходить для обычных рабочих нагрузок в кластере.

# вопросы по k8s 
Конечно, давайте пройдемся по этим вопросам и я предоставлю краткие ответы на них:

1. **Что такое Kubernetes и какие основные проблемы он решает?**
   - Kubernetes — это система оркестрации контейнеров, предоставляющая инструменты для развертывания, масштабирования и управления контейнеризированными приложениями. Он решает проблемы автоматического развертывания, масштабирования, самовосстановления и обеспечивает балансировку нагрузки.

2. **В чем разница между подом и контейнером в Kubernetes?**
   - Под — это минимальная и базовая единица развертывания в Kubernetes, содержащая один или несколько контейнеров. Контейнеры в одном поде разделяют те же сетевые и ресурсные пространства.

3. **Что такое ReplicaSet и как он отличается от Deployment?**
   - ReplicaSet гарантирует, что указанное количество реплик пода запущено и работает. Deployment добавляет функциональность обновления и отката к ReplicaSet.

4. **Объясните, как работает Service в Kubernetes и какие типы Service существуют.**
   - Service позволяет обращаться к группе подов по постоянному IP-адресу и DNS-имени. Существуют различные типы Service: ClusterIP, NodePort, LoadBalancer и ExternalName.

5. **Что такое Persistent Volumes (PV) и Persistent Volume Claims (PVC)? Как они связаны?**
   - PV — это кусок постоянного хранилища, который вы выделяете кластеру. PVC — это запрос на этот объем хранилища. Поды могут использовать PVC для хранения постоянных данных.

6. **Как вы масштабируете приложения в Kubernetes?**
   - С помощью команды `kubectl scale` или изменяя количество реплик в Deployment или ReplicaSet.

7. **Что такое ConfigMap и Secret? Каковы основные различия между ними?**
   - ConfigMap используется для хранения конфигурационных данных в виде пар ключ-значение, в то время как Secret используется для хранения конфиденциальной информации. Secrets обычно кодируются и предназначены для хранения паролей, токенов и других чувствительных данных.

8. **Объясните жизненный цикл пода.**
   - Поды проходят через несколько фаз: Pending (ожидание), Running (запуск), Succeeded (успешное завершение), Failed (неудачное завершение) и Unknown (неизвестное состояние).

9. **Что делают kubelet и kube-proxy на узле?**
   - Kubelet управляет контейнерами на узле, обеспечивая их запуск, остановку и мониторинг. Kube-proxy обеспечивает сетевую связь между подами и сервисами.

10. **Как Kubernetes обеспечивает безопасность и изоляцию между подами и контейнерами?**
   - С помощью средств изоляции на уровне ОС (например, namespaces и cgroups) и сетевой политики для контроля трафика между подами.

11. **Как вы мониторите здоровье приложений и инфраструктуры в Kubernetes?**
   - Можно использовать инструменты мониторинга, такие как Prometheus, Grafana, и интеграции с системами логирования, такими как Elasticsearch и Kibana.

12. **Что такое Helm и для чего он используется?**
   - Helm — это пакетный менеджер для Kubernetes, позволяющий упростить развертывание, обновление и управление приложениями в кластере.

13. **Как Kubernetes обеспечивает сетевую изоляцию между разными неймспейсами или разными пользовательскими группами?**
   - С помощью сетевых политик, которые позволяют контролировать, как поды общаются между собой на основе различных критериев.

14. **Как вы настраиваете логирование и мониторинг в Kubernetes?**
   - Для логирования можно использовать такие инструменты, как Fluentd или Logstash для сбора логов и Elasticsearch для их хранения. Для мониторинга — Prometheus и Grafana.

15. **Что такое Ingress в Kubernetes и как он работает?**
   - Ingress позволяет управлять доступом к сервисам из внешнего мира, обеспечивая маршрутизацию трафика и возможность использования SSL/TLS.

16. **Как вы можете обновить версию приложения, используя Kubernetes, без простоя?**
   - Используя стратегии обновления Deployment, такие как Rolling Update.

17. **Что такое StatefulSet и в каких сценариях он может быть полезен?**
   - StatefulSet используется для приложений, которым требуется стабильное состояние, например, баз

ы данных. Он гарантирует уникальные идентификаторы и стабильное хранилище для каждого инстанса.

18. **Как Kubernetes управляет секретами и конфиденциальной информацией?**
   - С помощью объектов Secret, которые позволяют хранить и управлять конфиденциальной информацией без ее раскрытия в конфигурации.

19. **Что такое сетевые политики в Kubernetes и как они используются?**
   - Сетевые политики определяют, как поды могут общаться между собой. Они позволяют создавать белые и черные списки для входящего и исходящего трафика.

20. **Как вы настраиваете автоматическое масштабирование приложений в Kubernetes?**
   - С помощью объекта Horizontal Pod Autoscaler (HPA), который масштабирует количество подов на основе определенных метрик, таких как использование CPU или памяти.
 
# Что происходит когда создается deployment

Kubernetes (часто сокращенно как K8s) – это мощная система оркестрации контейнеров, позволяющая автоматически развертывать, масштабировать и управлять контейнеризированными приложениями. Когда вы создаете Deployment в Kubernetes, происходит ряд действий:

1. **Определение Deployment**: Вы объявляете конфигурацию Deployment, используя YAML-файл. В этом файле указываются такие параметры, как имя Deployment, образ контейнера, который вы хотите запустить, число реплик и многое другое.

2. **Поступление в API Server**: Когда вы применяете Deployment (обычно с помощью `kubectl apply -f your-deployment.yaml`), ваше объявление отправляется на API server Kubernetes.

3. **Запись в etcd**: API server проверяет корректность вашего Deployment и, если все в порядке, сохраняет его в etcd. Etcd – это распределенное хранилище конфигурации, которое используется Kubernetes для хранения всех данных о состоянии кластера.

4. **Controller Manager реагирует**: Deployment Controller в Controller Manager замечает новый или измененный Deployment. Его задача – удостовериться, что текущее состояние (количество работающих контейнеров, например) соответствует заявленному в конфигурации.

5. **Создание ReplicaSet**: Deployment Controller создает объект ReplicaSet на основе конфигурации Deployment. ReplicaSet отвечает за то, чтобы нужное количество реплик вашего приложения всегда было запущено.

6. **Создание подов (Pods)**: ReplicaSet, в свою очередь, начинает создание подов. Под – это базовая единица работы в Kubernetes. Если вы указали в Deployment, что хотите 3 реплики вашего приложения, ReplicaSet попытается гарантировать, что 3 пода вашего приложения всегда запущены.

7. **Распределение подов по узлам**: Когда поды создаются, Scheduler Kubernetes выбирает, на каком узле (или машине) в вашем кластере они должны быть запущены, учитывая различные факторы (ресурсы, аффинити и т. д.).

8. **Запуск контейнеров**: На выбранных узлах kubelet получает команду на запуск подов, которые, в свою очередь, запускают контейнеры с вашим приложением внутри себя.

9. **Слежение за состоянием**: После создания подов и контейнеров, Controller Manager и kubelet будут наблюдать за их состоянием, чтобы удостовериться, что все работает правильно и соответствует заявленной конфигурации.

Весь этот процесс происходит автоматически и обычно занимает всего несколько секунд или минут. Основное преимущество использования Kubernetes заключается в том, что он автоматизирует многие аспекты управления жизненным циклом приложения, делая развертывание, масштабирование и восстановление приложений более простым и надежным.